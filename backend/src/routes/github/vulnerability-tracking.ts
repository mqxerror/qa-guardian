/**
 * Vulnerability Tracking Routes
 *
 * Contains routes for:
 * - Feature #773: Multi-language Dependency Support
 * - Feature #774: Dependency Vulnerability History
 * - Feature #775: Exploitability Analysis
 * - Feature #776: Dependency Scan Caching
 */

import { FastifyInstance } from 'fastify';
import { authenticate } from '../../middleware/auth';

// =====================================================
// Interfaces
// =====================================================

interface LanguageScanConfig {
  language: 'javascript' | 'python' | 'java' | 'go' | 'rust';
  enabled: boolean;
  manifest_files: string[];
  lock_files: string[];
  registries: string[];
}

interface MultiLanguageScanConfig {
  organization_id: string;
  enabled_languages: LanguageScanConfig[];
  scan_dev_dependencies: boolean;
  scan_transitive: boolean;
  auto_detect_languages: boolean;
  parallel_scanning: boolean;
  cache_duration_hours: number;
}

interface LanguageDependency {
  id: string;
  project_id: string;
  language: 'javascript' | 'python' | 'java' | 'go' | 'rust';
  name: string;
  current_version: string;
  latest_version: string;
  license?: string;
  is_dev: boolean;
  is_transitive: boolean;
  depth: number;
  parent_package?: string;
  repository_url?: string;
  registry: string;
  vulnerabilities: Array<{
    id: string;
    severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
    title: string;
    fixed_version?: string;
  }>;
  last_scanned_at: string;
}

interface LanguageScanResult {
  project_id: string;
  language: string;
  status: 'pending' | 'scanning' | 'completed' | 'failed';
  total_dependencies: number;
  direct_dependencies: number;
  transitive_dependencies: number;
  vulnerabilities_found: number;
  started_at?: string;
  completed_at?: string;
  error_message?: string;
}

interface VulnerabilityHistoryEvent {
  id: string;
  event_type: 'detected' | 'fixed' | 'acknowledged' | 'ignored' | 'reopened';
  timestamp: string;
  user_id?: string;
  user_name?: string;
  commit_sha?: string;
  commit_message?: string;
  branch?: string;
  notes?: string;
}

interface VulnerabilityHistory {
  id: string;
  vulnerability_id: string;
  cve_id: string;
  dependency_name: string;
  dependency_version: string;
  project_id: string;
  project_name: string;
  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
  title: string;
  description: string;
  first_detected_at: string;
  first_detected_commit?: string;
  first_detected_by?: string;
  fixed_at?: string;
  fixed_commit?: string;
  fixed_by?: string;
  fixed_in_version?: string;
  current_status: 'open' | 'fixed' | 'ignored' | 'false_positive';
  time_to_fix_days?: number;
  events: VulnerabilityHistoryEvent[];
}

interface ExploitabilityAnalysis {
  vulnerability_id: string;
  cve_id: string;
  dependency_name: string;
  dependency_version: string;
  epss_score: number;
  epss_percentile: number;
  reachability: {
    status: 'reachable' | 'potentially_reachable' | 'not_reachable' | 'unknown';
    confidence: number;
    call_paths: Array<{
      source_file: string;
      line_number: number;
      function_name: string;
      call_chain: string[];
    }>;
    affected_functions: string[];
    analysis_method: 'static' | 'dynamic' | 'hybrid' | 'manual';
  };
  known_exploits: {
    has_public_exploit: boolean;
    exploit_maturity: 'proof_of_concept' | 'functional' | 'weaponized' | 'none';
    exploit_sources: Array<{
      source: string;
      url?: string;
      date_published?: string;
    }>;
    in_the_wild: boolean;
    ransomware_associated: boolean;
  };
  kev_status: {
    is_in_kev: boolean;
    date_added?: string;
    due_date?: string;
    notes?: string;
  };
  risk_assessment: {
    overall_risk: 'critical' | 'high' | 'medium' | 'low' | 'informational';
    exploitability_score: number;
    impact_score: number;
    priority_score: number;
    recommended_action: string;
    remediation_effort: 'minimal' | 'moderate' | 'significant' | 'extensive';
  };
  analyzed_at: string;
  analysis_version: string;
}

interface ScanCacheEntry {
  id: string;
  project_id: string;
  scan_type: 'dependencies' | 'vulnerabilities' | 'licenses' | 'full';
  cache_key: string;
  package_lock_hash: string;
  results: {
    dependencies: number;
    vulnerabilities: number;
    scan_duration_ms: number;
    timestamp: string;
  };
  metadata: {
    node_version?: string;
    package_manager: string;
    dependency_count: number;
    dev_dependency_count: number;
  };
  created_at: string;
  expires_at: string;
  hit_count: number;
  last_accessed: string;
  status: 'valid' | 'stale' | 'invalidated';
}

interface CacheConfig {
  enabled: boolean;
  ttl_hours: number;
  max_entries: number;
  invalidation_triggers: string[];
  compression_enabled: boolean;
}

// =====================================================
// In-memory Storage
// =====================================================

const multiLangConfigs = new Map<string, MultiLanguageScanConfig>();
const languageDependencies = new Map<string, LanguageDependency[]>();
const scanResults = new Map<string, LanguageScanResult[]>();
const vulnerabilityHistories = new Map<string, VulnerabilityHistory[]>();
const exploitabilityCache = new Map<string, ExploitabilityAnalysis>();
const scanCacheStore = new Map<string, ScanCacheEntry>();
const projectCacheConfigs = new Map<string, CacheConfig>();

// =====================================================
// Helper Functions
// =====================================================

function generateMockDependencies(projectId: string, language: 'javascript' | 'python' | 'java' | 'go' | 'rust'): LanguageDependency[] {
  const langConfigs: Record<string, { packages: string[]; registry: string }> = {
    javascript: {
      packages: ['react', 'express', 'lodash', 'axios', 'typescript', 'webpack', 'babel-core', 'jest', 'eslint', 'prettier'],
      registry: 'npm',
    },
    python: {
      packages: ['django', 'flask', 'requests', 'numpy', 'pandas', 'pytest', 'black', 'mypy', 'sqlalchemy', 'celery'],
      registry: 'pypi',
    },
    java: {
      packages: ['spring-boot', 'junit', 'lombok', 'jackson', 'slf4j', 'guava', 'commons-io', 'mockito', 'hibernate', 'log4j'],
      registry: 'maven',
    },
    go: {
      packages: ['gin', 'gorm', 'cobra', 'viper', 'logrus', 'testify', 'echo', 'fiber', 'chi', 'zap'],
      registry: 'go',
    },
    rust: {
      packages: ['serde', 'tokio', 'actix-web', 'clap', 'reqwest', 'log', 'anyhow', 'thiserror', 'chrono', 'rand'],
      registry: 'crates.io',
    },
  };

  const config = langConfigs[language];
  const deps: LanguageDependency[] = [];

  config.packages.forEach((pkg, index) => {
    const isDev = index >= 7;
    const hasVuln = Math.random() < 0.15;

    deps.push({
      id: `dep-${language}-${index}`,
      project_id: projectId,
      language,
      name: pkg,
      current_version: `${Math.floor(Math.random() * 5)}.${Math.floor(Math.random() * 10)}.${Math.floor(Math.random() * 20)}`,
      latest_version: `${Math.floor(Math.random() * 5) + 1}.${Math.floor(Math.random() * 10)}.${Math.floor(Math.random() * 20)}`,
      license: ['MIT', 'Apache-2.0', 'BSD-3-Clause', 'ISC'][Math.floor(Math.random() * 4)],
      is_dev: isDev,
      is_transitive: false,
      depth: 0,
      registry: config.registry,
      vulnerabilities: hasVuln ? [{
        id: `VULN-${Math.floor(Math.random() * 10000)}`,
        severity: ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW'][Math.floor(Math.random() * 4)] as any,
        title: `Security vulnerability in ${pkg}`,
        fixed_version: `${Math.floor(Math.random() * 5) + 2}.0.0`,
      }] : [],
      last_scanned_at: new Date().toISOString(),
    });

    if (Math.random() < 0.5 && !isDev) {
      deps.push({
        id: `dep-${language}-${index}-trans`,
        project_id: projectId,
        language,
        name: `${pkg}-core`,
        current_version: `${Math.floor(Math.random() * 3)}.${Math.floor(Math.random() * 10)}.${Math.floor(Math.random() * 10)}`,
        latest_version: `${Math.floor(Math.random() * 3) + 1}.${Math.floor(Math.random() * 10)}.${Math.floor(Math.random() * 10)}`,
        license: 'MIT',
        is_dev: false,
        is_transitive: true,
        depth: 1,
        parent_package: pkg,
        registry: config.registry,
        vulnerabilities: [],
        last_scanned_at: new Date().toISOString(),
      });
    }
  });

  return deps;
}

function generateMockVulnerabilityHistory(projectId: string): VulnerabilityHistory[] {
  const dependencies = ['lodash', 'express', 'axios', 'moment', 'request', 'minimist', 'node-fetch'];
  const histories: VulnerabilityHistory[] = [];

  dependencies.forEach((dep, idx) => {
    if (Math.random() > 0.4) {
      const detectedDaysAgo = Math.floor(Math.random() * 90) + 10;
      const isFixed = Math.random() > 0.5;
      const fixedDaysAgo = isFixed ? Math.floor(Math.random() * detectedDaysAgo) : undefined;

      const history: VulnerabilityHistory = {
        id: `vuln-${projectId}-${idx}`,
        vulnerability_id: `vuln-${projectId}-${idx}`,
        cve_id: `CVE-2024-${1000 + idx * 100 + Math.floor(Math.random() * 100)}`,
        dependency_name: dep,
        dependency_version: `${Math.floor(Math.random() * 5)}.${Math.floor(Math.random() * 10)}.${Math.floor(Math.random() * 20)}`,
        project_id: projectId,
        project_name: 'Main Project',
        severity: ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW'][Math.floor(Math.random() * 4)] as any,
        title: `Security vulnerability in ${dep}`,
        description: `A security issue was found in ${dep} that could allow attackers to exploit the application.`,
        first_detected_at: new Date(Date.now() - detectedDaysAgo * 24 * 60 * 60 * 1000).toISOString(),
        first_detected_commit: Math.random().toString(36).substring(2, 10),
        first_detected_by: 'CI Scanner',
        current_status: isFixed ? 'fixed' : (Math.random() > 0.8 ? 'ignored' : 'open'),
        events: [
          {
            id: `evt-${idx}-1`,
            event_type: 'detected',
            timestamp: new Date(Date.now() - detectedDaysAgo * 24 * 60 * 60 * 1000).toISOString(),
            commit_sha: Math.random().toString(36).substring(2, 10),
            commit_message: `Added ${dep} dependency`,
            branch: 'main',
          },
        ],
      };

      if (isFixed && fixedDaysAgo !== undefined) {
        history.fixed_at = new Date(Date.now() - fixedDaysAgo * 24 * 60 * 60 * 1000).toISOString();
        history.fixed_commit = Math.random().toString(36).substring(2, 10);
        history.fixed_by = 'Developer';
        history.fixed_in_version = `${Math.floor(Math.random() * 5) + 1}.0.0`;
        history.time_to_fix_days = detectedDaysAgo - fixedDaysAgo;
        history.events.push({
          id: `evt-${idx}-2`,
          event_type: 'fixed',
          timestamp: history.fixed_at,
          user_name: 'Developer',
          commit_sha: history.fixed_commit,
          commit_message: `Upgraded ${dep} to fix vulnerability`,
        });
      }

      histories.push(history);
    }
  });

  return histories;
}

function getTopAffectedDependencies(histories: VulnerabilityHistory[]): Array<{ name: string; count: number; open: number }> {
  const depCounts: Record<string, { count: number; open: number }> = {};
  histories.forEach(h => {
    if (!depCounts[h.dependency_name]) {
      depCounts[h.dependency_name] = { count: 0, open: 0 };
    }
    depCounts[h.dependency_name].count++;
    if (h.current_status === 'open') {
      depCounts[h.dependency_name].open++;
    }
  });

  return Object.entries(depCounts)
    .map(([name, data]) => ({ name, ...data }))
    .sort((a, b) => b.count - a.count)
    .slice(0, 5);
}

function generateMockExploitabilityAnalysis(
  vulnerabilityId: string,
  cveId?: string,
  depName?: string,
  depVersion?: string
): ExploitabilityAnalysis {
  const epssScore = Math.random() * 0.8;
  const hasExploit = Math.random() > 0.7;
  const isReachable = Math.random() > 0.4;

  return {
    vulnerability_id: vulnerabilityId,
    cve_id: cveId || `CVE-2024-${Math.floor(Math.random() * 10000)}`,
    dependency_name: depName || 'lodash',
    dependency_version: depVersion || '4.17.15',
    epss_score: Math.round(epssScore * 1000) / 1000,
    epss_percentile: Math.round(epssScore * 100),
    reachability: {
      status: isReachable ? 'reachable' : (Math.random() > 0.5 ? 'potentially_reachable' : 'not_reachable'),
      confidence: Math.floor(Math.random() * 40) + 60,
      call_paths: isReachable ? [
        {
          source_file: 'src/index.ts',
          line_number: Math.floor(Math.random() * 500) + 1,
          function_name: 'handleRequest',
          call_chain: ['main', 'handleRequest', `${depName || 'lodash'}.merge`],
        },
      ] : [],
      affected_functions: [`${depName || 'lodash'}.merge`, `${depName || 'lodash'}.set`],
      analysis_method: 'static',
    },
    known_exploits: {
      has_public_exploit: hasExploit,
      exploit_maturity: hasExploit
        ? (['proof_of_concept', 'functional', 'weaponized'] as const)[Math.floor(Math.random() * 3)]
        : 'none',
      exploit_sources: hasExploit ? [
        { source: 'ExploitDB', url: 'https://exploit-db.com/exploits/12345', date_published: '2024-01-15' },
        { source: 'GitHub', url: 'https://github.com/exploit/poc', date_published: '2024-01-10' },
      ] : [],
      in_the_wild: hasExploit && Math.random() > 0.7,
      ransomware_associated: hasExploit && Math.random() > 0.9,
    },
    kev_status: {
      is_in_kev: hasExploit && Math.random() > 0.8,
      date_added: hasExploit ? '2024-02-01' : undefined,
      due_date: hasExploit ? '2024-02-15' : undefined,
      notes: hasExploit ? 'Active exploitation observed' : undefined,
    },
    risk_assessment: {
      overall_risk: epssScore > 0.5 && isReachable ? 'critical'
        : epssScore > 0.3 || hasExploit ? 'high'
        : epssScore > 0.1 ? 'medium'
        : 'low',
      exploitability_score: Math.round(epssScore * 10 * 10) / 10,
      impact_score: Math.round((Math.random() * 4 + 6) * 10) / 10,
      priority_score: Math.round((epssScore * 50 + (isReachable ? 30 : 0) + (hasExploit ? 20 : 0))),
      recommended_action: isReachable && hasExploit
        ? 'Immediate remediation required - active exploitation and reachable code path'
        : isReachable
        ? 'Prioritize remediation - vulnerable code path is reachable'
        : hasExploit
        ? 'Monitor closely - known exploit exists but code may not be reachable'
        : 'Standard remediation timeline acceptable',
      remediation_effort: Math.random() > 0.7 ? 'minimal' : Math.random() > 0.5 ? 'moderate' : 'significant',
    },
    analyzed_at: new Date().toISOString(),
    analysis_version: '1.0.0',
  };
}

function generateCacheKey(projectId: string, scanType: string, packageHash: string): string {
  return `${projectId}:${scanType}:${packageHash}`;
}

function generateMockCacheDependencies(count: number): any[] {
  const deps = [];
  const names = ['react', 'lodash', 'axios', 'express', 'webpack', 'typescript', 'jest', 'eslint', 'prettier', 'moment'];
  for (let i = 0; i < Math.min(count, 20); i++) {
    deps.push({
      name: names[i % names.length] + (i >= names.length ? `-${Math.floor(i / names.length)}` : ''),
      version: `${Math.floor(Math.random() * 10)}.${Math.floor(Math.random() * 10)}.${Math.floor(Math.random() * 10)}`,
      type: Math.random() > 0.3 ? 'production' : 'development',
    });
  }
  return deps;
}

function generateMockVulnerabilities(count: number): any[] {
  const vulns = [];
  for (let i = 0; i < count; i++) {
    vulns.push({
      id: `VULN-${1000 + i}`,
      severity: (['critical', 'high', 'medium', 'low'] as const)[Math.floor(Math.random() * 4)],
      package: `affected-package-${i}`,
      title: `Vulnerability ${i + 1}`,
    });
  }
  return vulns;
}

// =====================================================
// Routes Export
// =====================================================

export async function vulnerabilityTrackingRoutes(app: FastifyInstance): Promise<void> {
  // =====================================================
  // Feature #773: Multi-language Dependency Support
  // =====================================================

  app.get('/api/v1/organization/multi-language/config', { preHandler: [authenticate] }, async (request, reply) => {
    const orgId = 'org-1';

    let config = multiLangConfigs.get(orgId);
    if (!config) {
      config = {
        organization_id: orgId,
        enabled_languages: [
          {
            language: 'javascript',
            enabled: true,
            manifest_files: ['package.json'],
            lock_files: ['package-lock.json', 'yarn.lock', 'pnpm-lock.yaml'],
            registries: ['https://registry.npmjs.org'],
          },
          {
            language: 'python',
            enabled: true,
            manifest_files: ['requirements.txt', 'setup.py', 'pyproject.toml', 'Pipfile'],
            lock_files: ['Pipfile.lock', 'poetry.lock'],
            registries: ['https://pypi.org'],
          },
          {
            language: 'java',
            enabled: true,
            manifest_files: ['pom.xml', 'build.gradle', 'build.gradle.kts'],
            lock_files: ['gradle.lockfile'],
            registries: ['https://repo.maven.apache.org/maven2'],
          },
          {
            language: 'go',
            enabled: true,
            manifest_files: ['go.mod'],
            lock_files: ['go.sum'],
            registries: ['https://proxy.golang.org'],
          },
          {
            language: 'rust',
            enabled: true,
            manifest_files: ['Cargo.toml'],
            lock_files: ['Cargo.lock'],
            registries: ['https://crates.io'],
          },
        ],
        scan_dev_dependencies: true,
        scan_transitive: true,
        auto_detect_languages: true,
        parallel_scanning: true,
        cache_duration_hours: 24,
      };
      multiLangConfigs.set(orgId, config);
    }

    return config;
  });

  app.patch('/api/v1/organization/multi-language/config', { preHandler: [authenticate] }, async (request, reply) => {
    const orgId = 'org-1';
    const updates = request.body as Partial<MultiLanguageScanConfig>;

    let config = multiLangConfigs.get(orgId);
    if (!config) {
      return reply.code(404).send({ error: 'Configuration not found' });
    }

    config = { ...config, ...updates };
    multiLangConfigs.set(orgId, config);

    return config;
  });

  app.get<{ Params: { projectId: string } }>('/api/v1/projects/:projectId/detected-languages', { preHandler: [authenticate] }, async (request, reply) => {
    const { projectId } = request.params as { projectId: string };

    const detectedLanguages = [
      {
        language: 'javascript',
        confidence: 0.95,
        manifest_files_found: ['package.json'],
        lock_files_found: ['package-lock.json'],
        dependency_count: 142,
      },
      {
        language: 'python',
        confidence: 0.88,
        manifest_files_found: ['requirements.txt', 'pyproject.toml'],
        lock_files_found: [],
        dependency_count: 45,
      },
      {
        language: 'go',
        confidence: 0.92,
        manifest_files_found: ['go.mod'],
        lock_files_found: ['go.sum'],
        dependency_count: 28,
      },
    ];

    return {
      project_id: projectId,
      detected_at: new Date().toISOString(),
      languages: detectedLanguages,
      total_languages: detectedLanguages.length,
      recommended_scan_order: ['javascript', 'python', 'go'],
    };
  });

  app.post<{ Params: { projectId: string } }>('/api/v1/projects/:projectId/multi-language-scan', { preHandler: [authenticate] }, async (request, reply) => {
    const { projectId } = request.params as { projectId: string };
    const { languages } = request.body as { languages?: string[] };

    const scanId = `scan-${Date.now()}`;
    const languagesToScan = languages || ['javascript', 'python', 'java', 'go', 'rust'];

    const results: LanguageScanResult[] = languagesToScan.map(lang => ({
      project_id: projectId,
      language: lang,
      status: 'pending' as const,
      total_dependencies: 0,
      direct_dependencies: 0,
      transitive_dependencies: 0,
      vulnerabilities_found: 0,
    }));

    scanResults.set(scanId, results);

    setTimeout(() => {
      const updatedResults = results.map((result) => {
        const directDeps = Math.floor(Math.random() * 50) + 10;
        const transitiveDeps = Math.floor(Math.random() * 100) + 20;
        return {
          ...result,
          status: 'completed' as const,
          total_dependencies: directDeps + transitiveDeps,
          direct_dependencies: directDeps,
          transitive_dependencies: transitiveDeps,
          vulnerabilities_found: Math.floor(Math.random() * 10),
          started_at: new Date(Date.now() - 5000).toISOString(),
          completed_at: new Date().toISOString(),
        };
      });
      scanResults.set(scanId, updatedResults);
    }, 2000);

    return {
      scan_id: scanId,
      project_id: projectId,
      languages: languagesToScan,
      status: 'started',
      started_at: new Date().toISOString(),
      results,
    };
  });

  app.get<{ Params: { scanId: string } }>('/api/v1/scans/:scanId/status', { preHandler: [authenticate] }, async (request, reply) => {
    const { scanId } = request.params as { scanId: string };

    const results = scanResults.get(scanId);
    if (!results) {
      return reply.code(404).send({ error: 'Scan not found' });
    }

    const allCompleted = results.every(r => r.status === 'completed' || r.status === 'failed');
    const anyFailed = results.some(r => r.status === 'failed');

    return {
      scan_id: scanId,
      status: allCompleted ? (anyFailed ? 'completed_with_errors' : 'completed') : 'in_progress',
      results,
      summary: {
        total_languages: results.length,
        completed: results.filter(r => r.status === 'completed').length,
        failed: results.filter(r => r.status === 'failed').length,
        pending: results.filter(r => r.status === 'pending' || r.status === 'scanning').length,
        total_dependencies: results.reduce((sum, r) => sum + r.total_dependencies, 0),
        total_vulnerabilities: results.reduce((sum, r) => sum + r.vulnerabilities_found, 0),
      },
    };
  });

  app.get<{ Params: { projectId: string; language: string } }>('/api/v1/projects/:projectId/dependencies/:language', { preHandler: [authenticate] }, async (request, reply) => {
    const { projectId, language } = request.params as { projectId: string; language: string };
    const { include_transitive, include_dev } = request.query as { include_transitive?: string; include_dev?: string };

    const key = `${projectId}-${language}`;
    let deps = languageDependencies.get(key);

    if (!deps || deps.length === 0) {
      deps = generateMockDependencies(projectId, language as any);
      languageDependencies.set(key, deps);
    }

    let filteredDeps = deps;
    if (include_transitive !== 'true') {
      filteredDeps = filteredDeps.filter(d => !d.is_transitive);
    }
    if (include_dev !== 'true') {
      filteredDeps = filteredDeps.filter(d => !d.is_dev);
    }

    return {
      project_id: projectId,
      language,
      dependencies: filteredDeps,
      summary: {
        total: filteredDeps.length,
        direct: filteredDeps.filter(d => !d.is_transitive).length,
        transitive: filteredDeps.filter(d => d.is_transitive).length,
        dev: filteredDeps.filter(d => d.is_dev).length,
        with_vulnerabilities: filteredDeps.filter(d => d.vulnerabilities.length > 0).length,
      },
    };
  });

  app.get<{ Params: { projectId: string } }>('/api/v1/projects/:projectId/all-dependencies', { preHandler: [authenticate] }, async (request, reply) => {
    const { projectId } = request.params as { projectId: string };

    const allLanguages = ['javascript', 'python', 'java', 'go', 'rust'] as const;
    const allDeps: Record<string, LanguageDependency[]> = {};
    const summary: Record<string, any> = {};

    for (const lang of allLanguages) {
      const key = `${projectId}-${lang}`;
      let deps = languageDependencies.get(key);
      if (!deps || deps.length === 0) {
        deps = generateMockDependencies(projectId, lang);
        languageDependencies.set(key, deps);
      }
      allDeps[lang] = deps;
      summary[lang] = {
        total: deps.length,
        direct: deps.filter(d => !d.is_transitive).length,
        transitive: deps.filter(d => d.is_transitive).length,
        vulnerabilities: deps.filter(d => d.vulnerabilities.length > 0).length,
      };
    }

    return {
      project_id: projectId,
      dependencies_by_language: allDeps,
      summary,
      totals: {
        total_dependencies: Object.values(allDeps).reduce((sum, deps) => sum + deps.length, 0),
        total_vulnerabilities: Object.values(allDeps).reduce(
          (sum, deps) => sum + deps.filter(d => d.vulnerabilities.length > 0).length, 0
        ),
        languages_scanned: allLanguages.length,
      },
    };
  });

  app.get('/api/v1/organization/multi-language/stats', { preHandler: [authenticate] }, async (request, reply) => {
    const orgId = 'org-1';

    let totalDeps = 0;
    let totalVulns = 0;
    const langStats: Record<string, { dependencies: number; vulnerabilities: number; projects: number }> = {
      javascript: { dependencies: 0, vulnerabilities: 0, projects: 0 },
      python: { dependencies: 0, vulnerabilities: 0, projects: 0 },
      java: { dependencies: 0, vulnerabilities: 0, projects: 0 },
      go: { dependencies: 0, vulnerabilities: 0, projects: 0 },
      rust: { dependencies: 0, vulnerabilities: 0, projects: 0 },
    };

    languageDependencies.forEach((deps, key) => {
      const [, lang] = key.split('-');
      if (langStats[lang]) {
        langStats[lang].dependencies += deps.length;
        langStats[lang].vulnerabilities += deps.filter(d => d.vulnerabilities.length > 0).length;
        langStats[lang].projects += 1;
      }
      totalDeps += deps.length;
      totalVulns += deps.filter(d => d.vulnerabilities.length > 0).length;
    });

    return {
      organization_id: orgId,
      summary: {
        total_dependencies: totalDeps,
        total_vulnerabilities: totalVulns,
        languages_tracked: Object.keys(langStats).length,
        projects_scanned: new Set([...languageDependencies.keys()].map(k => k.split('-')[0])).size,
      },
      by_language: langStats,
      top_vulnerable_packages: [
        { name: 'lodash', language: 'javascript', vulnerabilities: 3 },
        { name: 'django', language: 'python', vulnerabilities: 2 },
        { name: 'log4j', language: 'java', vulnerabilities: 4 },
      ],
      license_distribution: {
        'MIT': 45,
        'Apache-2.0': 30,
        'BSD-3-Clause': 15,
        'ISC': 10,
      },
    };
  });

  // =====================================================
  // Feature #774: Dependency Vulnerability History
  // =====================================================

  app.get<{ Params: { projectId: string } }>('/api/v1/projects/:projectId/vulnerability-history', {
    preHandler: [authenticate],
  }, async (request) => {
    const { projectId } = request.params;
    const { status, severity, dependency } = request.query as {
      status?: string;
      severity?: string;
      dependency?: string;
    };

    let histories = vulnerabilityHistories.get(projectId);
    if (!histories || histories.length === 0) {
      histories = generateMockVulnerabilityHistory(projectId);
      vulnerabilityHistories.set(projectId, histories);
    }

    let filtered = histories;
    if (status) {
      filtered = filtered.filter(h => h.current_status === status);
    }
    if (severity) {
      filtered = filtered.filter(h => h.severity === severity);
    }
    if (dependency) {
      filtered = filtered.filter(h => h.dependency_name.toLowerCase().includes(dependency.toLowerCase()));
    }

    return {
      project_id: projectId,
      vulnerabilities: filtered,
      summary: {
        total: filtered.length,
        open: filtered.filter(h => h.current_status === 'open').length,
        fixed: filtered.filter(h => h.current_status === 'fixed').length,
        ignored: filtered.filter(h => h.current_status === 'ignored').length,
        false_positive: filtered.filter(h => h.current_status === 'false_positive').length,
        by_severity: {
          critical: filtered.filter(h => h.severity === 'CRITICAL').length,
          high: filtered.filter(h => h.severity === 'HIGH').length,
          medium: filtered.filter(h => h.severity === 'MEDIUM').length,
          low: filtered.filter(h => h.severity === 'LOW').length,
        },
        avg_time_to_fix_days: Math.round(
          filtered.filter(h => h.time_to_fix_days).reduce((sum, h) => sum + (h.time_to_fix_days || 0), 0) /
          Math.max(filtered.filter(h => h.time_to_fix_days).length, 1)
        ),
      },
    };
  });

  app.get<{ Params: { vulnerabilityId: string } }>('/api/v1/vulnerabilities/:vulnerabilityId/history', {
    preHandler: [authenticate],
  }, async (request) => {
    const { vulnerabilityId } = request.params;

    let history: VulnerabilityHistory | undefined;
    for (const [, histories] of vulnerabilityHistories) {
      history = histories.find(h => h.id === vulnerabilityId);
      if (history) break;
    }

    if (!history) {
      history = {
        id: vulnerabilityId,
        vulnerability_id: vulnerabilityId,
        cve_id: `CVE-2024-${Math.floor(Math.random() * 10000)}`,
        dependency_name: 'lodash',
        dependency_version: '4.17.15',
        project_id: 'proj-1',
        project_name: 'Main Project',
        severity: 'HIGH',
        title: 'Prototype Pollution in lodash',
        description: 'A vulnerability that allows prototype pollution through the merge function.',
        first_detected_at: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(),
        first_detected_commit: 'a1b2c3d4',
        first_detected_by: 'CI Scanner',
        current_status: 'open',
        events: [
          {
            id: 'evt-1',
            event_type: 'detected',
            timestamp: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(),
            commit_sha: 'a1b2c3d4',
            commit_message: 'Added lodash dependency for utility functions',
            branch: 'feature/new-utils',
            notes: 'Vulnerability detected during PR scan',
          },
          {
            id: 'evt-2',
            event_type: 'acknowledged',
            timestamp: new Date(Date.now() - 28 * 24 * 60 * 60 * 1000).toISOString(),
            user_id: 'user-1',
            user_name: 'John Developer',
            notes: 'Acknowledged - will fix in next sprint',
          },
        ],
      };
    }

    return history;
  });

  app.get<{ Params: { projectId: string } }>('/api/v1/projects/:projectId/vulnerability-timeline', {
    preHandler: [authenticate],
  }, async (request) => {
    const { projectId } = request.params;
    const { days } = request.query as { days?: string };

    const daysBack = parseInt(days || '30');
    const startDate = new Date(Date.now() - daysBack * 24 * 60 * 60 * 1000);

    let histories = vulnerabilityHistories.get(projectId);
    if (!histories || histories.length === 0) {
      histories = generateMockVulnerabilityHistory(projectId);
      vulnerabilityHistories.set(projectId, histories);
    }

    const allEvents: Array<{
      date: string;
      vulnerability_id: string;
      cve_id: string;
      dependency_name: string;
      severity: string;
      event_type: string;
      user_name?: string;
      commit_sha?: string;
    }> = [];

    histories.forEach(history => {
      history.events.forEach(event => {
        if (new Date(event.timestamp) >= startDate) {
          allEvents.push({
            date: event.timestamp,
            vulnerability_id: history.id,
            cve_id: history.cve_id,
            dependency_name: history.dependency_name,
            severity: history.severity,
            event_type: event.event_type,
            user_name: event.user_name,
            commit_sha: event.commit_sha,
          });
        }
      });
    });

    allEvents.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());

    const timeline: Record<string, typeof allEvents> = {};
    allEvents.forEach(event => {
      const dateKey = event.date.split('T')[0];
      if (!timeline[dateKey]) {
        timeline[dateKey] = [];
      }
      timeline[dateKey].push(event);
    });

    return {
      project_id: projectId,
      period_days: daysBack,
      total_events: allEvents.length,
      timeline,
      summary: {
        detected: allEvents.filter(e => e.event_type === 'detected').length,
        fixed: allEvents.filter(e => e.event_type === 'fixed').length,
        acknowledged: allEvents.filter(e => e.event_type === 'acknowledged').length,
        ignored: allEvents.filter(e => e.event_type === 'ignored').length,
      },
    };
  });

  app.patch<{ Params: { vulnerabilityId: string } }>('/api/v1/vulnerabilities/:vulnerabilityId/status', {
    preHandler: [authenticate],
  }, async (request, reply) => {
    const { vulnerabilityId } = request.params;
    const { status, notes, fixed_version } = request.body as {
      status: 'open' | 'fixed' | 'ignored' | 'false_positive';
      notes?: string;
      fixed_version?: string;
    };

    let history: VulnerabilityHistory | undefined;
    let foundProjectId: string | undefined;
    for (const [projectId, histories] of vulnerabilityHistories) {
      const idx = histories.findIndex(h => h.id === vulnerabilityId);
      if (idx >= 0) {
        history = histories[idx];
        foundProjectId = projectId;
        break;
      }
    }

    if (!history || !foundProjectId) {
      return reply.code(404).send({ error: 'Vulnerability not found' });
    }

    const newEvent: VulnerabilityHistoryEvent = {
      id: `evt-${Date.now()}`,
      event_type: status === 'fixed' ? 'fixed' : status === 'ignored' || status === 'false_positive' ? 'ignored' : 'acknowledged',
      timestamp: new Date().toISOString(),
      user_id: 'user-current',
      user_name: 'Current User',
      notes,
    };

    history.events.push(newEvent);
    history.current_status = status;

    if (status === 'fixed') {
      history.fixed_at = new Date().toISOString();
      history.fixed_by = 'Current User';
      history.fixed_in_version = fixed_version;
      history.time_to_fix_days = Math.round(
        (new Date().getTime() - new Date(history.first_detected_at).getTime()) / (24 * 60 * 60 * 1000)
      );
    }

    return {
      success: true,
      message: `Vulnerability status updated to ${status}`,
      vulnerability: history,
    };
  });

  app.get<{ Params: { projectId: string } }>('/api/v1/projects/:projectId/vulnerability-stats', {
    preHandler: [authenticate],
  }, async (request) => {
    const { projectId } = request.params;

    let histories = vulnerabilityHistories.get(projectId);
    if (!histories || histories.length === 0) {
      histories = generateMockVulnerabilityHistory(projectId);
      vulnerabilityHistories.set(projectId, histories);
    }

    const fixedVulns = histories.filter(h => h.current_status === 'fixed' && h.time_to_fix_days);
    const avgTimeToFix = fixedVulns.length > 0
      ? Math.round(fixedVulns.reduce((sum, h) => sum + (h.time_to_fix_days || 0), 0) / fixedVulns.length)
      : 0;

    const monthlyTrends: Record<string, { detected: number; fixed: number }> = {};
    histories.forEach(h => {
      const month = h.first_detected_at.substring(0, 7);
      if (!monthlyTrends[month]) {
        monthlyTrends[month] = { detected: 0, fixed: 0 };
      }
      monthlyTrends[month].detected++;
      if (h.fixed_at) {
        const fixMonth = h.fixed_at.substring(0, 7);
        if (!monthlyTrends[fixMonth]) {
          monthlyTrends[fixMonth] = { detected: 0, fixed: 0 };
        }
        monthlyTrends[fixMonth].fixed++;
      }
    });

    return {
      project_id: projectId,
      overall: {
        total_vulnerabilities: histories.length,
        currently_open: histories.filter(h => h.current_status === 'open').length,
        fixed_all_time: histories.filter(h => h.current_status === 'fixed').length,
        average_time_to_fix_days: avgTimeToFix,
        oldest_open_days: Math.max(
          ...histories
            .filter(h => h.current_status === 'open')
            .map(h => Math.round((Date.now() - new Date(h.first_detected_at).getTime()) / (24 * 60 * 60 * 1000))),
          0
        ),
      },
      by_severity: {
        critical: {
          open: histories.filter(h => h.severity === 'CRITICAL' && h.current_status === 'open').length,
          fixed: histories.filter(h => h.severity === 'CRITICAL' && h.current_status === 'fixed').length,
        },
        high: {
          open: histories.filter(h => h.severity === 'HIGH' && h.current_status === 'open').length,
          fixed: histories.filter(h => h.severity === 'HIGH' && h.current_status === 'fixed').length,
        },
        medium: {
          open: histories.filter(h => h.severity === 'MEDIUM' && h.current_status === 'open').length,
          fixed: histories.filter(h => h.severity === 'MEDIUM' && h.current_status === 'fixed').length,
        },
        low: {
          open: histories.filter(h => h.severity === 'LOW' && h.current_status === 'open').length,
          fixed: histories.filter(h => h.severity === 'LOW' && h.current_status === 'fixed').length,
        },
      },
      monthly_trends: monthlyTrends,
      top_affected_dependencies: getTopAffectedDependencies(histories),
    };
  });

  // =====================================================
  // Feature #775: Exploitability Analysis
  // =====================================================

  app.get<{ Params: { vulnerabilityId: string } }>('/api/v1/vulnerabilities/:vulnerabilityId/exploitability', {
    preHandler: [authenticate],
  }, async (request) => {
    const { vulnerabilityId } = request.params;

    let analysis = exploitabilityCache.get(vulnerabilityId);
    if (!analysis) {
      analysis = generateMockExploitabilityAnalysis(vulnerabilityId);
      exploitabilityCache.set(vulnerabilityId, analysis);
    }

    return analysis;
  });

  app.get<{ Params: { projectId: string } }>('/api/v1/projects/:projectId/exploitability-analysis', {
    preHandler: [authenticate],
  }, async (request) => {
    const { projectId } = request.params;
    const { reachable_only, min_epss } = request.query as { reachable_only?: string; min_epss?: string };

    let histories = vulnerabilityHistories.get(projectId);
    if (!histories || histories.length === 0) {
      histories = generateMockVulnerabilityHistory(projectId);
      vulnerabilityHistories.set(projectId, histories);
    }

    const analyses: ExploitabilityAnalysis[] = histories.map(h => {
      let analysis = exploitabilityCache.get(h.id);
      if (!analysis) {
        analysis = generateMockExploitabilityAnalysis(h.id, h.cve_id, h.dependency_name, h.dependency_version);
        exploitabilityCache.set(h.id, analysis);
      }
      return analysis;
    });

    let filtered = analyses;
    if (reachable_only === 'true') {
      filtered = filtered.filter(a =>
        a.reachability.status === 'reachable' || a.reachability.status === 'potentially_reachable'
      );
    }
    if (min_epss) {
      const minScore = parseFloat(min_epss);
      filtered = filtered.filter(a => a.epss_score >= minScore);
    }

    return {
      project_id: projectId,
      analyses: filtered,
      summary: {
        total_analyzed: filtered.length,
        reachable: filtered.filter(a => a.reachability.status === 'reachable').length,
        potentially_reachable: filtered.filter(a => a.reachability.status === 'potentially_reachable').length,
        not_reachable: filtered.filter(a => a.reachability.status === 'not_reachable').length,
        unknown: filtered.filter(a => a.reachability.status === 'unknown').length,
        with_known_exploits: filtered.filter(a => a.known_exploits.has_public_exploit).length,
        in_kev: filtered.filter(a => a.kev_status.is_in_kev).length,
        high_risk: filtered.filter(a => a.risk_assessment.overall_risk === 'critical' || a.risk_assessment.overall_risk === 'high').length,
        avg_epss_score: filtered.length > 0
          ? Math.round(filtered.reduce((sum, a) => sum + a.epss_score, 0) / filtered.length * 1000) / 1000
          : 0,
      },
    };
  });

  app.post<{ Params: { vulnerabilityId: string } }>('/api/v1/vulnerabilities/:vulnerabilityId/analyze-reachability', {
    preHandler: [authenticate],
  }, async (request) => {
    const { vulnerabilityId } = request.params;
    const { method } = request.body as { method?: 'static' | 'dynamic' | 'hybrid' };

    const analysisId = `analysis-${Date.now()}`;

    let analysis = exploitabilityCache.get(vulnerabilityId);
    if (!analysis) {
      analysis = generateMockExploitabilityAnalysis(vulnerabilityId);
    }

    analysis.reachability = {
      status: Math.random() > 0.3 ? 'reachable' : (Math.random() > 0.5 ? 'potentially_reachable' : 'not_reachable'),
      confidence: Math.floor(Math.random() * 40) + 60,
      call_paths: [
        {
          source_file: 'src/services/dataProcessor.ts',
          line_number: 142,
          function_name: 'processInput',
          call_chain: ['main', 'handleRequest', 'processInput', `${analysis.dependency_name}.parse`],
        },
        {
          source_file: 'src/utils/validator.ts',
          line_number: 87,
          function_name: 'validateData',
          call_chain: ['api.handler', 'validateData', `${analysis.dependency_name}.validate`],
        },
      ],
      affected_functions: [`${analysis.dependency_name}.parse`, `${analysis.dependency_name}.validate`, `${analysis.dependency_name}.merge`],
      analysis_method: method || 'static',
    };
    analysis.analyzed_at = new Date().toISOString();

    exploitabilityCache.set(vulnerabilityId, analysis);

    return {
      success: true,
      analysis_id: analysisId,
      vulnerability_id: vulnerabilityId,
      reachability: analysis.reachability,
      message: `Reachability analysis completed using ${method || 'static'} method`,
    };
  });

  app.get<{ Params: { projectId: string } }>('/api/v1/projects/:projectId/epss-scores', {
    preHandler: [authenticate],
  }, async (request) => {
    const { projectId } = request.params;

    let histories = vulnerabilityHistories.get(projectId);
    if (!histories || histories.length === 0) {
      histories = generateMockVulnerabilityHistory(projectId);
      vulnerabilityHistories.set(projectId, histories);
    }

    const epssData = histories.map(h => {
      let analysis = exploitabilityCache.get(h.id);
      if (!analysis) {
        analysis = generateMockExploitabilityAnalysis(h.id, h.cve_id, h.dependency_name, h.dependency_version);
        exploitabilityCache.set(h.id, analysis);
      }
      return {
        vulnerability_id: h.id,
        cve_id: h.cve_id,
        dependency_name: h.dependency_name,
        severity: h.severity,
        epss_score: analysis.epss_score,
        epss_percentile: analysis.epss_percentile,
        has_known_exploit: analysis.known_exploits.has_public_exploit,
        is_reachable: analysis.reachability.status === 'reachable',
      };
    });

    epssData.sort((a, b) => b.epss_score - a.epss_score);

    return {
      project_id: projectId,
      vulnerabilities: epssData,
      distribution: {
        high_risk: epssData.filter(e => e.epss_score >= 0.5).length,
        medium_risk: epssData.filter(e => e.epss_score >= 0.1 && e.epss_score < 0.5).length,
        low_risk: epssData.filter(e => e.epss_score < 0.1).length,
      },
      last_updated: new Date().toISOString(),
    };
  });

  // =====================================================
  // Feature #776: Dependency Scan Caching
  // =====================================================

  app.get<{ Params: { projectId: string } }>('/api/v1/projects/:projectId/scan-cache/config', {
    preHandler: [authenticate],
  }, async (request) => {
    const { projectId } = request.params;

    let config = projectCacheConfigs.get(projectId);
    if (!config) {
      config = {
        enabled: true,
        ttl_hours: 24,
        max_entries: 100,
        invalidation_triggers: ['package.json', 'package-lock.json', 'yarn.lock', 'pnpm-lock.yaml'],
        compression_enabled: true,
      };
      projectCacheConfigs.set(projectId, config);
    }

    return config;
  });

  app.patch<{ Params: { projectId: string } }>('/api/v1/projects/:projectId/scan-cache/config', {
    preHandler: [authenticate],
  }, async (request) => {
    const { projectId } = request.params;
    const updates = request.body as Partial<CacheConfig>;

    let config = projectCacheConfigs.get(projectId);
    if (!config) {
      config = {
        enabled: true,
        ttl_hours: 24,
        max_entries: 100,
        invalidation_triggers: ['package.json', 'package-lock.json', 'yarn.lock', 'pnpm-lock.yaml'],
        compression_enabled: true,
      };
    }

    const updatedConfig = { ...config, ...updates };
    projectCacheConfigs.set(projectId, updatedConfig);

    return {
      success: true,
      config: updatedConfig,
    };
  });

  app.post<{ Params: { projectId: string } }>('/api/v1/projects/:projectId/scan-with-cache', {
    preHandler: [authenticate],
  }, async (request) => {
    const { projectId } = request.params;
    const { scan_type, force_refresh } = request.body as { scan_type?: string; force_refresh?: boolean };

    const scanStartTime = Date.now();
    const type = scan_type || 'full';

    const mockPackageHash = `hash-${projectId}-${Math.floor(Date.now() / 3600000)}`;
    const cacheKey = generateCacheKey(projectId, type, mockPackageHash);

    const cachedEntry = scanCacheStore.get(cacheKey);
    const config = projectCacheConfigs.get(projectId) || { enabled: true, ttl_hours: 24 };

    if (cachedEntry && config.enabled && !force_refresh && cachedEntry.status === 'valid') {
      const now = new Date();
      const expiresAt = new Date(cachedEntry.expires_at);

      if (now < expiresAt) {
        cachedEntry.hit_count += 1;
        cachedEntry.last_accessed = now.toISOString();
        scanCacheStore.set(cacheKey, cachedEntry);

        const cachedDuration = 50 + Math.random() * 100;

        return {
          scan_id: `scan-${Date.now()}`,
          project_id: projectId,
          cache_hit: true,
          cache_entry_id: cachedEntry.id,
          scan_duration_ms: Math.round(cachedDuration),
          saved_time_ms: cachedEntry.results.scan_duration_ms - Math.round(cachedDuration),
          results: {
            dependencies: generateMockCacheDependencies(cachedEntry.metadata.dependency_count),
            vulnerabilities: generateMockVulnerabilities(cachedEntry.results.vulnerabilities),
            total_dependencies: cachedEntry.metadata.dependency_count,
            total_vulnerabilities: cachedEntry.results.vulnerabilities,
          },
          cache_info: {
            key: cacheKey,
            created_at: cachedEntry.created_at,
            expires_at: cachedEntry.expires_at,
            hit_count: cachedEntry.hit_count,
          },
        };
      }
    }

    const fullScanDuration = 2000 + Math.random() * 3000;
    await new Promise(resolve => setTimeout(resolve, 100));

    const depCount = 100 + Math.floor(Math.random() * 200);
    const vulnCount = Math.floor(Math.random() * 20);

    const newEntry: ScanCacheEntry = {
      id: `cache-${Date.now()}`,
      project_id: projectId,
      scan_type: type as any,
      cache_key: cacheKey,
      package_lock_hash: mockPackageHash,
      results: {
        dependencies: depCount,
        vulnerabilities: vulnCount,
        scan_duration_ms: Math.round(fullScanDuration),
        timestamp: new Date().toISOString(),
      },
      metadata: {
        node_version: '20.11.0',
        package_manager: 'npm',
        dependency_count: depCount,
        dev_dependency_count: Math.floor(depCount * 0.3),
      },
      created_at: new Date().toISOString(),
      expires_at: new Date(Date.now() + (config.ttl_hours || 24) * 3600000).toISOString(),
      hit_count: 0,
      last_accessed: new Date().toISOString(),
      status: 'valid',
    };

    scanCacheStore.set(cacheKey, newEntry);

    const actualDuration = Date.now() - scanStartTime;

    return {
      scan_id: `scan-${Date.now()}`,
      project_id: projectId,
      cache_hit: false,
      cache_entry_id: newEntry.id,
      scan_duration_ms: Math.max(actualDuration, Math.round(fullScanDuration / 10)),
      results: {
        dependencies: generateMockCacheDependencies(depCount),
        vulnerabilities: generateMockVulnerabilities(vulnCount),
        total_dependencies: depCount,
        total_vulnerabilities: vulnCount,
      },
      cache_info: {
        key: cacheKey,
        created_at: newEntry.created_at,
        expires_at: newEntry.expires_at,
        hit_count: 0,
      },
    };
  });

  app.get<{ Params: { projectId: string } }>('/api/v1/projects/:projectId/scan-cache/stats', {
    preHandler: [authenticate],
  }, async (request) => {
    const { projectId } = request.params;

    const projectEntries = Array.from(scanCacheStore.values())
      .filter(e => e.project_id === projectId);

    const validEntries = projectEntries.filter(e => e.status === 'valid');
    const totalHits = projectEntries.reduce((sum, e) => sum + e.hit_count, 0);
    const totalSavedTime = projectEntries.reduce((sum, e) => sum + (e.hit_count * e.results.scan_duration_ms * 0.9), 0);

    return {
      project_id: projectId,
      total_entries: projectEntries.length,
      valid_entries: validEntries.length,
      stale_entries: projectEntries.filter(e => e.status === 'stale').length,
      invalidated_entries: projectEntries.filter(e => e.status === 'invalidated').length,
      total_cache_hits: totalHits,
      total_time_saved_ms: Math.round(totalSavedTime),
      cache_hit_rate: projectEntries.length > 0
        ? Math.round((totalHits / (totalHits + projectEntries.length)) * 100)
        : 0,
      storage_used_bytes: projectEntries.length * 5000,
      oldest_entry: projectEntries.length > 0
        ? projectEntries.reduce((oldest, e) => e.created_at < oldest.created_at ? e : oldest).created_at
        : null,
      newest_entry: projectEntries.length > 0
        ? projectEntries.reduce((newest, e) => e.created_at > newest.created_at ? e : newest).created_at
        : null,
    };
  });

  app.get<{ Params: { projectId: string } }>('/api/v1/projects/:projectId/scan-cache/entries', {
    preHandler: [authenticate],
  }, async (request) => {
    const { projectId } = request.params;
    const { status } = request.query as { status?: string };

    let entries = Array.from(scanCacheStore.values())
      .filter(e => e.project_id === projectId);

    if (status) {
      entries = entries.filter(e => e.status === status);
    }

    return {
      project_id: projectId,
      entries: entries.map(e => ({
        id: e.id,
        scan_type: e.scan_type,
        cache_key: e.cache_key,
        status: e.status,
        hit_count: e.hit_count,
        scan_duration_ms: e.results.scan_duration_ms,
        dependencies: e.results.dependencies,
        vulnerabilities: e.results.vulnerabilities,
        created_at: e.created_at,
        expires_at: e.expires_at,
        last_accessed: e.last_accessed,
      })),
      total: entries.length,
    };
  });

  app.post<{ Params: { projectId: string } }>('/api/v1/projects/:projectId/scan-cache/invalidate', {
    preHandler: [authenticate],
  }, async (request) => {
    const { projectId } = request.params;
    const { entry_ids, invalidate_all, reason } = request.body as {
      entry_ids?: string[];
      invalidate_all?: boolean;
      reason?: string;
    };

    let invalidated = 0;

    if (invalidate_all) {
      scanCacheStore.forEach((entry, key) => {
        if (entry.project_id === projectId && entry.status === 'valid') {
          entry.status = 'invalidated';
          scanCacheStore.set(key, entry);
          invalidated++;
        }
      });
    } else if (entry_ids && entry_ids.length > 0) {
      scanCacheStore.forEach((entry, key) => {
        if (entry.project_id === projectId && entry_ids.includes(entry.id) && entry.status === 'valid') {
          entry.status = 'invalidated';
          scanCacheStore.set(key, entry);
          invalidated++;
        }
      });
    }

    return {
      success: true,
      invalidated_count: invalidated,
      reason: reason || 'Manual invalidation',
      timestamp: new Date().toISOString(),
    };
  });

  app.delete<{ Params: { projectId: string } }>('/api/v1/projects/:projectId/scan-cache', {
    preHandler: [authenticate],
  }, async (request) => {
    const { projectId } = request.params;

    let deleted = 0;
    const keysToDelete: string[] = [];

    scanCacheStore.forEach((entry, key) => {
      if (entry.project_id === projectId) {
        keysToDelete.push(key);
        deleted++;
      }
    });

    keysToDelete.forEach(key => scanCacheStore.delete(key));

    return {
      success: true,
      deleted_count: deleted,
      timestamp: new Date().toISOString(),
    };
  });
}